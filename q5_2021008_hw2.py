# -*- coding: utf-8 -*-
"""q5_2021008_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CojG0SaGASsECD3x5l1YLT-G5BjWpItT
"""

!pip3 install open3d
!pip install pyntcloud

import numpy as np
import cv2 as cv
import glob
import matplotlib.pyplot as plt
import os
import open3d as o3d
from pyntcloud import PyntCloud

lidar_paths = []
camera_images_paths = []
camera_param_paths = []

lidar_root = 'drive/MyDrive/CV_HW2/CV-A2-calibration/lidar_scans'
for p in os.listdir(lidar_root):
    lidar_paths.append(os.path.join(lidar_root, p))

camera_images = 'drive/MyDrive/CV_HW2/CV-A2-calibration/camera_images'
for p in os.listdir(camera_images):
    camera_images_paths.append(os.path.join(camera_images, p))

camera_params = 'drive/MyDrive/CV_HW2/CV-A2-calibration/camera_parameters'
for p in os.listdir(camera_params):
    if '.jpeg' in p:
        camera_param_paths.append(os.path.join(camera_params, p))

lidar_paths = sorted(lidar_paths)
camera_images_paths = sorted(camera_images_paths)
camera_param_paths = sorted(camera_param_paths)

def compute_plane_normal_and_offset(pcd_file):
    pcd = o3d.io.read_point_cloud(lidar_path)
    points = np.asarray(pcd.points)
    mean_point = np.mean(points, axis=0)
    centered = points - mean_point

    U, S, Vt = np.linalg.svd(np.dot(centered.T, centered), full_matrices = False)

    normal_vector = U[:, 2]

    d = np.dot(normal_vector, mean_point)
    if d < 0:
        d = -d
        normal_vector = -normal_vector

    return normal_vector, d

lidar_normals = []
offsets = []
for lidar_path in lidar_paths:
    normal_vector, offset = compute_plane_normal_and_offset(lidar_path)
    lidar_normals.append(normal_vector)
    offsets.append(offset)
    print(f"Normal Vector: {normal_vector}")
    print(f"Normal Offset: {offset}")

alpha_camera, camera_normals  = [], []
for cam_params in camera_param_paths:
    tvec = np.array(np.loadtxt(os.path.join(cam_params, "translation_vectors.txt")))
    normals = np.array(np.loadtxt(os.path.join(cam_params, "camera_normals.txt")))
    alpha_cam = np.dot(tvec, normals.T)

    if(alpha_cam < 0):
        alpha_cam = -alpha_cam
        normals = -normals
    camera_normals.append(normals)
    alpha_camera.append(alpha_cam)

alpha_c = np.array(alpha_camera)
alpha_l = np.array(offsets)
theta_l = np.array(lidar_normals)
theta_c = np.array(camera_normals)

theta_c

print(theta_c.shape)

normals_dot = np.dot(theta_l.T, theta_c)
U, S, V = np.linalg.svd(normals_dot)
R1 = np.dot(V.T, U.T)
inverse = np.linalg.inv(np.dot(theta_c.T, theta_c))
mid = np.dot(inverse, theta_c.T )
t1 = np.dot(mid, (alpha_c - alpha_l))

print(R1, t1)

cTl = np.zeros((4,4))
cTl[:3,:3] = R1
cTl[:3,3] = t1
cTl[3][3] = 1
print("estimated transformation matrix:")
print(cTl)

camera_intrinsic = np.array(np.loadtxt(os.path.join(camera_params, "camera_intrinsic.txt")))
distortion = np.array(np.loadtxt(os.path.join(camera_params, "distortion.txt")))

projected_points = []
i = 0

for lidar_path in lidar_paths:
    pcd = o3d.io.read_point_cloud(lidar_path)
    points = np.asarray(pcd.points)
    img = cv.imread(camera_images_paths[i])
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    ret, corners = cv.findChessboardCorners(gray, (8, 6), None)

    ones = np.ones((points.shape[0], 1))
    points_homogeneous = np.hstack((points, ones))

    camera_points_homogeneous = np.dot(cTl, points_homogeneous.T)

    camera_points = camera_points_homogeneous[:3, :] / camera_points_homogeneous[3, :]


    image_points = np.dot(camera_intrinsic, camera_points)
    image_points = image_points[:2, :] / image_points[2, :]

    if ret:
        projected_points.append(image_points.T)

    i += 1

i = 0
for cam_path in camera_images_paths:

    img = cv.imread(cam_path)
    gray = cv.cvtColor(img, cv.COLOR_BGR2RGB)
    ret, corners =cv.findChessboardCorners(gray, (8, 6), None)
    if(ret == True):
        points = projected_points[i]
        i += 1
        for p in points:
            cv.circle(gray, (int(p[0]), int(p[1])), 10, (255, 0, 0), 1)

    plt.imshow(gray)
    plt.show()

print(theta_c.shape)

print(theta_c)

print(theta_c[1])

fig = plt.figure(figsize=(15, 10))
lidar_normals_transformed = np.dot(theta_l, R1.T)

for i in range(5):
    ax = fig.add_subplot(2, 3, i+1, projection='3d')

    camera_normal = theta_c[i] / np.linalg.norm(theta_c[i])


    ax.quiver(0, 0, 0, camera_normal[0], camera_normal[1], camera_normal[2], color='g', label=f'Camera Normal {i}')

    ax.set_xlim([-1, 1])
    ax.set_ylim([-1, 1])
    ax.set_zlim([-1, 1])
    ax.set_xlabel('X axis')
    ax.set_ylabel('Y axis')
    ax.set_zlabel('Z axis')
    ax.legend()

plt.tight_layout()
plt.show()

fig = plt.figure(figsize=(15, 10))
lidar_normals_transformed = np.dot(theta_l, R1.T)

for i in range(5):
    ax = fig.add_subplot(2, 3, i+1, projection='3d')

    camera_normal = theta_c[i] / np.linalg.norm(theta_c[i])

    ax.quiver(0, 0, 0, lidar_normals[i][0], lidar_normals[i][1], lidar_normals[i][2], color='r', label=f'Lidar Normal {i}')
    ax.quiver(0, 0, 0, camera_normal[0], camera_normal[1], camera_normal[2], color='g', label=f'Camera Normal {i}')
    ax.quiver(0, 0, 0, lidar_normals_transformed[i][0], lidar_normals_transformed[i][1], lidar_normals_transformed[i][2], color='b', label=f'Transformed Lidar Normal {i}')

    ax.set_xlim([-1, 1])
    ax.set_ylim([-1, 1])
    ax.set_zlim([-1, 1])
    ax.set_xlabel('X axis')
    ax.set_ylabel('Y axis')
    ax.set_zlabel('Z axis')
    ax.legend()

plt.tight_layout()
plt.show()

lidar_paths_scans = lidar_paths[:5]

fig, axes = plt.subplots(1, 5, figsize=(25, 5))

for i, file_path in enumerate(lidar_paths_scans):
    pcd = o3d.io.read_point_cloud(file_path)

    lidar_data = np.asarray(pcd.points)
    geom = o3d.geometry.PointCloud()
    geom.points = o3d.utility.Vector3dVector(lidar_data)
    o3d.visualization.draw_plotly([geom])


    axes[i].scatter(lidar_data[:, 0], lidar_data[:, 1], s=1)


    axes[i].set_title(f'LIDAR Scan {i+1}')
    axes[i].set_xlabel('X axis')
    axes[i].set_ylabel('Y axis')
    axes[i].axis('equal')

plt.tight_layout()
plt.show()

lidar_normals_transformed = np.dot(theta_l, R1.T)

cosine_distances = []

for i in range(38):
    dst = 1 - (np.dot(camera_normals[i], lidar_normals_transformed[i]) / (np.linalg.norm(camera_normals[i]) * np.linalg.norm(lidar_normals_transformed[i])))
    cosine_distances.append(dst)


plt.hist(cosine_distances)
plt.title('Histogram of Cosine Distances')
plt.xlabel('Cosine Distance')
plt.ylabel('Frequency')
plt.show()

average_error = np.mean(cosine_distances)
std_deviation = np.std(cosine_distances)

print(f"Average Error: {average_error}")
print(f"Standard Deviation: {std_deviation}")